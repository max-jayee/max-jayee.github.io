<link rel="stylesheet" type="text/css" href="/css/header.css">
<link rel="stylesheet" type="text/css" href="/css/bootstrap/5.3.0-alpha1/bootstrap.css">
<div class="sticky-top bg-white pt-1 pb-2" id="header-div-max"></div>
<details id="display-none"><summary></summary>
  <script src="/js/header.js" defer="defer"></script>
  <script src="/js/table/numbering.js" defer="defer"></script>
  <script src="/js/bootstrap/5.3.0-alpha1/bootstrap.bundle.js" defer="defer"></script>
</details>

# Software Architecture

## Definition

- software architecture
  1. architecture characteristic: 가용성, 신뢰성, 시험성, 확장성, 보안, 민첩성, 내고장성, 탄력성, 복구성, 성능, 배포성, 학습성과 같이 다른 관점에서 바라본 것으로, 시스템의 기능과 직교하는 시스템의 겅공 기준을 결정한다.
  2. architecture decision: 비즈니스, 서비스레이어에서만 퍼시스턴스 레이어에 접근할 수 있다 와 같이 시스템의 제약조건을 형성하여, 개발자가 해도 되는 것과 하지 말아야할 것을 정의한다.
  3. design principle: 마이크로 서비스 간 통신은 비동기 메시징을 활용해야 한다고 기술하는 것과 같은 가이드라인과 유사한 설계 원칙이다.
  4. structure: 마이크로서비스, 레이어드, 마이크로커널과 같이 아키텍처 스타일의 종류를 의미한다.

- software architect
  1. 아키텍처 결정을 내린다.
  2. 아키텍처를 지속적으로 분석한다.
  3. 최신 트렌드를 계속 유지한다.
  4. 아키텍처 결정의 컴플라이언스를 보장한다.
  5. 다양한 기술과 경험에 노출한다.
  6. 비즈니스 도메인 지식을 보유한다.
  7. 대인 관계 기술이 뛰어나다.
  8. 정치를 이해하고 처세를 잘한다.

- architectural thinking
  1. 아키텍처와 설계의 차이를 이해하고 아키텍처 작업을 진행하려면 개발팀과 어떻게 협력해야 할 지 아는 것
  2. 기술 깊이를 유지하면서 폭 넓은 기술 지식을 확보하는 것 (다른 사람이 보지 못하는 해결책과 가능성 떠올릴 수 있음)
  3. 다양한 솔루션과 기술 간의 트레이드 오프를 이해하고, 분석하고, 조율하는 것
  4. 비즈니스 드라이버의 중요성을 이해하고 그것을 아키텍처 관심사로 해석할 줄 아는 것

- architecture
  1. 주로 아키텍트 영역
  2. 아키텍처 특성 정의
  3. 컴포넌트 구조 설계

- design
  1. 주로 개발자 영역
  2. 클래스 설계
  3. 소스 코드 작성

- 기술 피라미드
  1. 내가 알고 있는 것 - 기술 깊이
  2. 내가 모른다는 사실을 아는 것 - 기술 폭
  3. 내가 모른다는 사실조차 모르는 것

- 모듈성 측정
  1. 응집: 한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는지 나타냄  
    모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가 를 의미함
     1. 기능적 응집: 모듈의 각 파트는 다른 파트와 연관되어 있고, 기능상 꼭 필요한 모든 것이 모듈에 들어있다.
     2. 순차적 응집: 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용 한다.
     3. 소통적 응집: 두 모듈이, 각자 정보에 따라 작동하거나 어떤 출력을 내는 형태로 통신 체인을 형성한다.
     4. 절차적 응집: 두 모듈은 정해진 순서대로 실행되어야 한다.
     5. 일시적 응집: 모듈은 시점 의존성에 따라 연관된다.
     6. 논리적 응집: 모듈의 내부 데이터는 기능적이 아니라, 논리적으로 연관되어 있다.
     7. 동시적 응집: 같은 소스 파일에 모듈 구성 요소가 들어 있지만 그 외에는 아무 연관성도 없다.
  2. 커플링: 모듈간 결합도
  3. 커네이선스: 변화 종속성으로 어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태

- 아키텍처 특성
  1. 비기능(비도메인) 요구사항: 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없는 것들
  2. 운영 아키텍처: 성능, 확장성, 탄력성, 가용성, 신뢰성 등의 능력을 의미한다.
     1. 가용성(availability): 시스템이 얼마나 오랫동안 사용가능하나? (장애를 몇개까지 수용하나)
     2. 연속성(continuity): 재해 복구 능력
     3. 성능(performance): 스트레스 테스트, 피크 분석, 사용 빈도 분석, 필요 용량, 응답 시간 등
     4. 복구성(recoverability): 백업 전략, 비즈니스 연속성 요구사항
     5. 신뢰성/안전(reliability / safety): fail-safe 가 필요한가, 시스템 실패 시 회사에 손실이 발생하는가?
     6. 견고성(robustness): 프로그램 실행 중 인터넷 접속 끊김, 정전, 하드웨어 실패 등 에러 및 경계 조건을 감당하는 능력
     7. 확장성(scalability): 유저 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력
  3. 구조 아키텍처: 코드 구조에 관심을 갖고, 우수한 모듈성, 컴포넌트 간 커플링 제어, 가독성 높은 코드, 그 밖의 내부 품질 평가 등 코드 품질 문제를 전담
     1. 설정성(configurability): end user 가 소프트웨어 설정을 쉽게 바꿀 수 있는가?
     2. 신장성(extensibility): 새로운 기능을 삽입하는 일의 중요성
     3. 설치성(installability): 필요한 모든 플랫폼에 시스템을 얼마나 손쉽게 설치할 수 있나?
     4. 활용성/재사용성(leverageability/reuse): 공통 컴포넌트를 여러 제품에서 활용할 수 있나?
     5. 지역성(locality): 데이터를 입력/조회하는 화면에서 다국어가 지원되는가? 화폐 단위 등
     6. 유지보수성(maintainability): 시스템을 얼마나 쉽게 변경/개선할 수 있나?
     7. 이식성(portability): 하나 이상의 플랫폼에서 시스템을 실행할 수 있나?
     8. 지원성(supportability): 어플리케이션은 어느 정도의 기술 지원을 필요로 하나? 로그레벨 등
     9. 업그레이드성(upgradeability): 버전 업그레이드가 용이한가
  4. 아키텍처 공통
     1. 접근성(accessilibyt): 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없나?
     2. 보관성(archivability): 데이터를 따로 archiving 해야하나
     3. 인증(authentication):유저가 본인이 맞다는 것을 증명하기 위해 필요한 보안 요구사항
     4. 인가(authorization): 유저가 어플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항
     5. 합법성(legal): 시스템 운영상 법적 제약조건이 있는가?
     6. 프라이버시(privacy): 회사 내부 임직원의 트랜잭션을 외부에 드러내지 않는 기능
     7. 보안(security): 데이터를 암호화한 후 데이터베이스에 보관해야하나? 네트워크 통신도 암호화해야하나?
     8. 사용성/성취성(usability/achievability): 유저가 어플리케이션/솔루션을 이용하여 원하는 목적을 달성하기 위해 필요한 교육/훈련 수준

- 컴포넌트 사고
  1. 모듈: 연관된 코드의 묶음
  2. 컴포넌트: 모듈을 물리적으로 구현한 것(물리적으로 패키징 한 것 - jar, dll, gem 등의 파일로 )으로 아키텍트들은 의미함

- 아키텍처 패턴
  1. 아키텍처 스타일에서 특정한 솔루션(고확장성/고성능을 실현하는 방법 등)을 마련하는 데 유용한 저수준의 설계 구조

- 아키텍처 스타일
  1. 유저 인터페이스와 백엔드 소스 코드를 구성하는 방법
  2. 소스 코드가 데이터 저장소와 상호작용하는 방법에 관한 결정적으로 중요한 구조
  3. 1 Tier(진흙잡탕): 별다른 스타일이 없고 데이터베이스를 직접 호출하는 이벤트 핸들러를 가진 단순한 스크립팅 애플리케이션
  4. 2 Tier(클라이언트/서버): 프론트 엔드와 백 엔드로 기술적으로 기능을 분리한 스타일
  5. 3 Tier: 데이터베이스 티어(db server), 애플리케이션 티어(application server), 프론트엔드 티어(front end server) 로 구성된 분산 아키텍처인 공통 객체 요청 브로커 아키텍처CORBA(Common Object Request Broker Architecture), 분산 컴포넌트 객체 모델DCOM(Distributed Component Object Model) 과 잘 어울림

- 모놀리식 아키텍처 스타일: 전체 코드를 단일 단위로 배포하는 스타일
  1. 레이어드 아키텍처
  2. 파이프라인 아키텍처
  3. 마이크로커널 아키텍처

- 분산형 아키텍처 스타일: 원격 액세스 프로토콜을 통해 여러 단위로 배포되는 스타일
  1. 서비스 기반 아키텍처
  2. 이벤트 기반 아키텍처
  3. 공간 기반 아키텍처
  4. 서비스 지향 아키텍처
  5. 마이크로서비스 아키텍처

- 분산형 아키텍처 vs 모놀리식 아키텍처
  1. 성능, 확장성, 가용성 측면에서는 분산형 아키텍처가 훨씬 강력하다.
  2. 하지만 무시할 수 없는 트레이드 오프가 수반됨: 'the fallacies of distributed computing: 분산 컴퓨팅의 오류'라는 글에서 최초 언급됨 (오류=옳다고 믿거나 가정하지만 실은 틀린 것을 의미)
  3. 오류 #1 - 네트워크는 믿을 수 있다.
     - 네트워크의 신뢰도가 증가하고 있다고는 하나, 보장할 수 있는 것은 아니다.
     - client 가 server 에 요청하였지만 못받을 수 있다. 이를 극복하기 위해 timeout 이나 circuit breaker 를 둔다.
  4. 오류 #2 - 레이턴시는 0이다.
     - 대게 local 에서 처리되는 시간은 나노 초 내지 밀리초 에서 처리되지만, remote 에서 처리되는 시간은 네트워크 시간을 사용하기에 더 크다.
     - 처리속도가 짧지만 이런 경우가 100번이상 반복되면 느리게 되는 거처럼 (예: 4ms 가 100번이면 400ms 이다..) 이런 경우를 long tail 레이턴시라고하며 분산 아키텍처의 성능을 저해하는 주범이다.
  5. 오류 #3 - 대역폭은 무한하다.
     - 서비스 A 가 없어서 서비스 B 에게 요청하는 형태를 stamp coupling 이라고 하며, 이런 경우 필요한 데이터 외에 불필요한 데이터도 처리되기에 네트워크에 상당히 많은 대역폭을 차지할 수 있다.
  6. 오류 #4 - 네트워크는 안전하다.
     - 아키텍트와 개발자는 대부분 vpn, trusted network, 방화벽 등에 익숙한 나머지 네트워크가 안전하지 않다는 사실을 망각한다.
     - 엔드포인트가 늘어날 수록 위험에 노출되는 상황이 더 많다.
     - 그렇다고 보안을 무조건 적용하면 성능이 떨어질 수 밖에 없다.
  7. 오류 $5 - 토폴로지는 절대 안 바뀐다.
     - 네트워크를 구성하는 모든 라우터, 허브, 스위치, 방화벽, 네트워크, 어플라이언스 등 전체 네트워크 토폴로지는 언제든 바뀔 수 있다.
  8. 오류 #6 - 관리자는 한 사람뿐이다.
     - 아키텍트는 언제나 한 사람의 관리자와만 협의하고 소통하면 된다는 오류에 빠지곤 한다.
     - 큰 규모의 업체에서는 네트워크 관리자만 수십 명에 이르기에 관련자들이 모두 논의되어야한다.
  9. 오류 #7 - 운송비는 0이다.
     - 여기서의 운송비는 단순한 원격 콜을 이용하는데 소요되는 진짜 비용(돈)을 의미한다.
     - 분산 서비스를 나누면 하드웨어, 서버, 게이트웨이, 방화벽, 신규 서브넷, 프록시 등 리소스에 들어가는 돈이 어마어마하다.
  10. 오류 #8 - 네트워크는 균일하다.
      - 실제 환경에서는 여러 회사의 제품들로 네트워크가 구성되어있어, 아무리 표준을 지켰다고해도 제품간 호환등의 문제로 예기치 문제가 발생할 수 있다.
  11. 분산 로깅
      - 어플리케이션과 시스템 로그가 분산되어 있어 어떤 데이터가 누락된 근본 원일을 밝혀내기가 대단히 어렵고 시간도 많이 걸린다.
      - 또한 로그 종류, 위치, 포맷도 제각각이라서 어떻게 로깅을 할 지 고민이 필요하다.
  12. 분산 트랜잭션
      - 모놀리식 아키텍처 세계에서 아키텍트, 개발자는 직관적이고 관리가 편한 트랜잭션을 당연시한다.
      - 퍼시스턴스 프레임워크가 대신 실행하는 표준 커밋/롤백 기능은 ACID(atomicity - 원자성, consistency - 일관성, isolation - 격리성, durability - 지속성) 트랜잭션을 걸어 업데이트 시 데이터 일관성과 무결성을 강제한다.
      - 하지만 분산 아키텍처는 최종 일관성 (eventual consistency)라는 개념을 바탕으로 별도로 분리된 배포 단위에서 처리된 데이터를 미리 알 수 없는 어느 시점에 모두 일관된 상태로 동기화 한다. (확장성, 성능, 가용성을 얻는 대가로, 데이터 일관성, 무결성을 의생하는 트레이드오프임)
      - 분산 트랜잭션을 관리하는 방법으로는 transactional saga(finite state machine 활용) 와 BASE(basic availability, soft state, eventual consistency)가 있다.
  13. 계약 관리 및 버저닝
      - 계약 생성, 유지보수, 버저닝 도 까다롭다.
      - 분산 아키텍처에서는 분리된 서비스와 시스템을 제각기 다른 팀과 부서가 소유하기 때문에 계약 유지보수가 특히 어렵다.

- 레이어드 아키텍처 스타일
  1. 각 레이어는 아키텍처 내부에서 특정한 역할과 임무를 수행한다.
  2. 각 레이어는 close 또는 open 상태이다.
  3. closed layer 란, 요청이 상위 레이어에서 하위 레이어로 이동하므로 중간의 어떤 레이어도 건너뛸 수 없고 현재 레이어를 거쳐야 바로 그 다음 레이어로 나아갈 수 있다는 뜻
  4. 비용이 저렴하고, 단순한 스타일

- 파이프라인 아키텍처 스타일
  1. 다수의 파이프와 필터로 구성되며, 보통 필터 간 단방향 통신은 점대점 방식으로 구성한다.
  2. 파이프: 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터 간 통신 채널이다.
  3. 필터: self-contained(자기 완비형)이고, 다른 필터와 독립적이며, 일반적으로 stateless 으로 한 가지 태스크만 수행한다.
  4. 필터의 4가지 종류
     - 프로듀서(producer): 프로세스의 시작점으로, outbound 만 있고 source 라고도 한다.
     - 변환기(transformer): 입력을 받아 데이터를 변환한 후 결과를 outbound pipe 로 전달한다. 함수형 프로그래밍에서는 이 기능을 map 이라고 한다.
     - 테스터(tester): 입력을 받아 하나 이상의 기준(criteria)에 대해 테스트를 하고 그 결과에 따라 필요시 결과를 생산한다. 함수형 프로그패밍에서는 이 기능을 reduce 라고 한다.
     - 컨슈머(consumer): 파이프라인 흐름의 종착역으로, 파이프라인의 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시한다.
  5. 비용이 저렴하고, 매우 단순한 스타일

- 마이크로커널 아키텍처 스타일
